#!/usr/bin/env ruby

puts 'Loading environment...'
require File.expand_path('../../config/environment', __FILE__)
puts "Running in #{Rails.env} mode..."

require 'trollop'

options = Trollop.options do
  opt :data, 'Data file(s)/directory', type: :strings
  opt :format, 'Metadata format (csv, mods, etd, cyl)', type: :string
  opt :metadata, 'Metadata file(s)/directory', type: :strings
  opt :number, 'Only ingest N records', type: :integer
  opt :skip, 'Skip the first N records', default: 0
  opt :verbose, 'Provide additional output', default: false
end

require File.expand_path('../../lib/importer', __FILE__)
AdminPolicy.ensure_admin_policy_exists

require 'fileutils'
require 'find'
require 'json'
require 'traject'

metadata_ext = case options[:format]
               when 'csv'
                 '.csv'
               else
                 '.xml'
               end

# For each argument passed to --metadata, if it's a file, add it
# to the array, otherwise drill down and add each file within to
# the array
meta = if options[:metadata]
         options[:metadata].map do |arg|
           if File.file?(arg)
             arg
           else
             next unless Dir.exist?(arg)
             files = []
             Find.find(arg) do |path|
               next unless File.extname(path) == metadata_ext
               files << path
             end
             files
           end
         end.flatten
       else
         []
       end

# For each argument passed to --data, if it's a file, add it to
# the array, otherwise drill down and add each file within to the
# array
data = if options[:data]
         if options[:format] == 'cyl'
           options[:data] # Just pass the options through
         else
           options[:data].map do |arg|
             if File.file?(arg)
               arg
             else
               next unless Dir.exist?(arg)
               datas = []
               Find.find(arg) do |path|
                 next if File.directory?(path)
                 datas << path
               end
               datas
             end
           end.flatten.compact
         end
       end
data ||= []

if data.empty?
  puts
  puts "\033[1;39mWarning: no data sources specified.\033[0m"
  puts
end

if options[:verbose]
  puts
  puts 'Metadata inputs:'
  meta.each { |m| puts m }
  puts
  puts 'Data inputs:'
  data.each { |d| puts d }
end

######################
# Begin ingest process
######################
start_overall = Time.now
ingests = 0

puts "Import start time: #{start_overall.strftime("%Y-%m-%d %H:%M:%S")}"

begin
  case options[:format]
  when 'csv'
    ingests = Importer::CSV.import(meta, data, options)
  when 'mods'
    ingests = Importer::MODS.import(meta, data, options)
  when 'etd'
    # lib/proquest
    require 'proquest'

    [Settings.download_root,
     Settings.marc_directory,
     Settings.proquest_directory].each do |dir|
      FileUtils.mkdir_p dir unless Pathname.new(dir).exist?
    end

    if data.empty?
      $stderr.puts 'Nothing found in the data path you specified.'
      exit 1
    end

    Dir.mktmpdir do |temp|
      # Don't unzip ETDs we won't use
      etds = data.drop(options[:skip]).map.with_index do |zip, i|
        next unless File.extname(zip) == '.zip'

        # i starts at zero, so use greater-than instead of >=
        if !options[:number] || options[:number] > i
          Proquest.extract(zip, "#{temp}/#{File.basename(zip)}")
        end
      end.compact

      if etds.empty?
        raise ArgumentError, "Number of records skipped (#{options[:skip]}) greater than total records to ingest"
      end

      marc = if options[:metadata]
               options[:metadata].map do |m|
                 # Enumerable methods on XMLReaders are destructive,
                 # so pull the individual records into a regular
                 # Array; see
                 # https://github.com/ruby-marc/ruby-marc/pull/47
                 MARC::XMLReader.new(m).map { |o| o }
               end
             else
               puts 'No metadata provided; fetching from Pegasus'
               etds.map { |e| e[:xml] }.map do |x|
                 if x.nil?
                   $stderr.puts "Bad zipfile source: #{e}"
                   raise IngestError
                 end
                 MARC::XMLReader.new(
                   StringIO.new(
                     Importer::ETD.parse_file(x)
                   )
                 ).map { |o| o }
               end
             end.flatten

      marc.each_with_index do |record, count|
        next if options[:number] && options[:number] <= ingests

        # The 956$f MARC field holds the name of the PDF from
        # ProQuest; we need this field to match data with metadata
        if record['956'].nil?
          $stderr.puts record
          $stderr.puts
          $stderr.puts 'MARC is missing 956$f field; cannot process this record'
          next
        end

        start_record = Time.now

        indexer = Traject::Indexer.new
        indexer.load_config_file('lib/traject/etd_config.rb')

        proquest_data = etds.select do |etd|
          etd[:pdf].include? record['956']['f']
        end.first
        indexer.settings(etd: proquest_data)

        if options[:verbose]
          puts
          puts "Object attributes for item #{count + 1}:"
          puts record
          puts
          puts "Associated data for item #{count + 1}:"
          puts proquest_data
        end

        begin
          indexer.writer.put indexer.map_record(record)
          indexer.writer.close
          end_record = Time.now
          # Since earlier we skipped the unzip operations we don't
          # need, the array of records to iterate over is smaller, so
          # we modify the numbers here so that we still get the
          # correct "Ingested X of out Y records" readout.
          puts "Ingested record #{count + 1 + options[:skip]} of #{etds.length + options[:skip]} "\
               "in #{end_record - start_record} seconds (#{end_record - start_overall} seconds elapsed)"
          ingests += 1
        rescue => e
          puts e
          puts e.backtrace
          raise IngestError.new(reached: count)
        rescue Interrupt
          puts "\nIngest stopped, cleaning up..."
          raise IngestError.new(reached: count)
        end
      end
    end
  when 'cyl'
    begin
      importer = Importer::Cylinder.new(meta, data, options)
      importer.run
    rescue => e
      puts e
      puts e.backtrace
      raise IngestError.new(reached: options[:skip] + importer.imported_records_count)
    ensure
      ingests = importer.imported_records_count
    end
  end  # case/when

  end_overall = Time.now
  puts "Ingested #{ingests} records in #{(end_overall - start_overall) / 60} minutes"
rescue IngestError => e
  puts
  end_overall = Time.now
  puts "Ingested #{e.reached} records in #{(end_overall - start_overall) / 60} minutes"
  puts
  puts "To continue this ingest, re-run the command with `--skip #{e.reached}`"
  exit 1
end
